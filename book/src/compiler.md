# Compiler

![](images/norpc-stack.png)

The stacks in red are generated by the compiler which is implemented
by the procedural macros.

You can define your service by `norpc::service` macro which generates
code in compile time.
The generated code includes message type, client type
and server-side `Service` type.

```rust
#[norpc::service]
trait HelloWorld {
    fn hello(s: String) -> String;
}
```

Note that these types are runtime-agnostic which means
you can write your own norpc runtime to run these codes for a specific case.

## More Examples

### Option or Result

You can return `Option` or `Result` types to
propagate some failure back to the client.

```rust
#[norpc::service]
trait YourService {
    fn read(id: u64) -> Option<Bytes>;
    fn write(id: u64, b: Bytes) -> Result<usize, ()>;
}
```

### Non-Send

You can generate non-Send service by add `?Send` parameter to `norpc::service` macro.

This is useful when you want to run the service in pinned thread.

```rust
#[norpc::service(?Send)]
trait YourService {
    // Rc<T> is !Send
    fn echo(s: Rc<String>) -> Rc<String>;
}
```