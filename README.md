# norpc

## Motivation

Developing an async application is often very difficult task but
building an async application as a set of microservices makes designing and implementation much easier.

gRPC is a great tool in microservices. You can use this for communication over networking but this isn't good idea unless networking involves.

In such case, in-process microservices is a way to go. The services run on async runtime and communicate each other over in-memory async channel which doesn't occur serialization therefore much more efficient than gRPC.
I believe in-process microservices is a new design paradigm for local async applications.

However, defining microservices in Rust does need a lot of coding for each services and they are mostly boilerplates. It will be helpful if these tidious tasks are swiped away by code generation.

[tarpc](https://github.com/google/tarpc) is a previous work in this area however it is not a best framework for in-process microservices because it tries to support both in-process and networking microservices under the same abstraction. This isn't a good idea because the both implementation will because sub-optimal. In my opinion, networking microservices should use gRPC and in-process microservices should use dedicated framework for the specific purpose.

Also, tarpc doesn't use Tower's `Service` but define a similar abstraction called `Serve` by itself. This leads to reimplement functions like rate-limiting and timeout which can be realized by just stacking `Service` decorators if depends on Tower. Since tarpc needs gigantic rework to become Tower-based, there is a chance to implement my own framework from scratch which will be much smaller and cleaner than tarpc because it only supports in-process microservices and is able to exploit the Tower ecosystem.

## Architecture

![スクリーンショット 2021-11-18 1 11 53](https://user-images.githubusercontent.com/785824/142237795-1c32aeba-428c-4c0c-b9ea-125580c0b178.png)

- Red: Code generated by norpc compiler
- Cyan: Reusable components provided by norpc library
- Yellow: Components from external libraries like Tokio and Tower

**norpc utilizes Tower ecosystem.**
The core of the Tower ecosystem is an abstraction called `Service` which is like a function from `Request` to `Response`.
The ecosystem has many decorators to add new behavior to the existing `Service`.

The client requests is coming from the top-left of the stacks and flows down to the bottom-right.
The client and server is connected by async channel driven by Tokio runtime so there is no overhead for the serialization
and copying because the message just "moves".

The red stacks will be auto-generated by norpc compiler.
Given a service file similar to protobuf's equivalent, norpc compiler generates Rust code from it.

Example:

```
service HelloWorld {
	fn read(id: u64) -> Option<String>;
	fn write(id: u64, s: String) -> ();
	fn write_many(kv: HashSet<(u64, String)>) -> ();
	fn noop() -> ();
}
```

Please see example for detail.