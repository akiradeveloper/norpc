<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>norpc</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="motivation.html"><strong aria-hidden="true">1.</strong> Motivation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="message-passsing.html"><strong aria-hidden="true">1.1.</strong> Message Passing</a></li><li class="chapter-item expanded "><a href="previous-work.html"><strong aria-hidden="true">1.2.</strong> Previous Work</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compiler.html"><strong aria-hidden="true">2.1.</strong> Compiler</a></li><li class="chapter-item expanded "><a href="runtime.html"><strong aria-hidden="true">2.2.</strong> Runtime</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">norpc</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#motivation" id="motivation">Motivation</a></h1>
<p>In this chapter,
I will tell you why I started this project.</p>
<h1><a class="header" href="#message-passing" id="message-passing">Message Passing</a></h1>
<p>To share state between async processes, these two possible solutions can be considered</p>
<ol>
<li>Shared memory</li>
<li>Message passing</li>
</ol>
<p>The benefit of message passing is
the processes are isolated and only communicated using defined messages.
Each process typically holds some resources like storage or connection to external service as a sole owner
and encapsulates the direct access to the resource from other processes.
This makes developing async applications easy because your interest is minimized.</p>
<p>You can also read this documentation from Tokio.
<a href="https://tokio.rs/tokio/tutorial/channels">https://tokio.rs/tokio/tutorial/channels</a></p>
<h2><a class="header" href="#problem-boilarplate" id="problem-boilarplate">Problem: Boilarplate</a></h2>
<p>Let's design your async application by message passing.
In this case, you have to define your own message types for request and response by hand
and may have to write some logics that consumes messages from channel or send response to the sender
using oneshot channel. From the Tokio documentation this could be like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use tokio::sync::oneshot;
use bytes::Bytes;

/// Multiple different commands are multiplexed over a single channel.
#[derive(Debug)]
enum Command {
    Get {
        key: String,
        resp: Responder&lt;Option&lt;Bytes&gt;&gt;,
    },
    Set {
        key: String,
        val: Bytes,
        resp: Responder&lt;()&gt;,
    },
}

/// Provided by the requester and used by the manager task to send
/// the command response back to the requester.
type Responder&lt;T&gt; = oneshot::Sender&lt;mini_redis::Result&lt;T&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>while let Some(cmd) = rx.recv().await {
    match cmd {
        Command::Get { key, resp } =&gt; {
            let res = client.get(&amp;key).await;
            // Ignore errors
            let _ = resp.send(res);
        }
        Command::Set { key, val, resp } =&gt; {
            let res = client.set(&amp;key, val).await;
            // Ignore errors
            let _ = resp.send(res);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However, writing such codes is really tedious.</p>
<h2><a class="header" href="#solution-code-generation" id="solution-code-generation">Solution: Code generation</a></h2>
<p>The solution is to generate code so you can 
focus on the logics rather than the boilarplates.</p>
<p>With norpc, you can define your in-memory microservice
like this and this will generate all the other tedious codes.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[norpc::service]
trait YourService {
    fn get(key: String) -&gt; Option&lt;Bytes&gt;;
    fn set(key: String, val: Bytes);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#previous-work" id="previous-work">Previous Work</a></h1>
<p><a href="https://github.com/google/tarpc">Tarpc</a> is a previous work in this area.</p>
<p>You can define your service by trait and the macro <code>tarpc::service</code> generates all the rest of the codes.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[tarpc::service]
pub trait World {
    async fn hello(name: String) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#problems" id="problems">Problems</a></h2>
<p>However, I found two problems in Tarpc.</p>
<h3><a class="header" href="#1-tarpc-isnt-optimized-for-in-memory-channel" id="1-tarpc-isnt-optimized-for-in-memory-channel">1. Tarpc isn't optimized for in-memory channel</a></h3>
<p>The goal of tarpc is providing RPC through TCP channel
and the direct competitor is RPC framework like <a href="https://github.com/hyperium/tonic">Tonic</a>
or <a href="https://github.com/paritytech/jsonrpc">jsonrpc</a>.</p>
<p>Tarpc only allows to use in-memory channel under the same abstraction
so the implementation isn't optimized for in-memory channel.</p>
<h3><a class="header" href="#2-tarpc-doesnt-use-tower" id="2-tarpc-doesnt-use-tower">2. Tarpc doesn't use Tower</a></h3>
<p><a href="https://github.com/tower-rs/tower">Tower</a> is a framework like
Scala's <a href="https://twitter.github.io/finagle/">Finagle</a>
which provides a abstraction called <code>Service</code> which is like a function from request to response
and decorator stacks to add more functionality on top of the abstraction.</p>
<p>If we design a RPC framework from scratch with the current Rust ecosystem,
we will 100% choose to depend on Tower to implement
functionalities like rate-limiting or timeout which is essential in doing RPC.
In fact, Tonic does so.</p>
<p>However, Tarpc's started a long ago before the current Rust ecosystem is established
and it doesn't use Tower but implements those functionalities by itself.</p>
<h1><a class="header" href="#architecture" id="architecture">Architecture</a></h1>
<p><img src="images/norpc-stack.png" alt="" /></p>
<p>norpc utilizes Tower ecosystem.</p>
<p>The core of the Tower ecosystem is an abstraction called <code>Service</code> which is like a function from request to response.
The ecosystem has many decorator stacks to add new behavior to an existing <code>Service</code>.</p>
<p>In the diagram, client requests are coming from the top-left of the stacks and flow down to the bottom-right.
The client and server is connected by async channel driven by some async runtime (like Tokio) so there is no overhead for
the serialization and copying because the messages just &quot;move&quot;.</p>
<h1><a class="header" href="#compiler" id="compiler">Compiler</a></h1>
<p><img src="images/norpc-stack.png" alt="" /></p>
<p>The stacks in red are generated by the compiler which is implemented
by the procedural macros.</p>
<p>You can define your service by <code>norpc::service</code> macro which generates
code in compile time.
The generated code includes message type, client type
and server-side <code>Service</code> type.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[norpc::service]
trait HelloWorld {
    fn hello(s: String) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that these types are runtime-agnostic which means
you can write your own norpc runtime to run these codes for a specific case.</p>
<h2><a class="header" href="#more-examples" id="more-examples">More Examples</a></h2>
<h3><a class="header" href="#option-or-result" id="option-or-result">Option or Result</a></h3>
<p>You can return <code>Option</code> or <code>Result</code> types to
propagate some failure back to the client.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[norpc::service]
trait YourService {
    fn read(id: u64) -&gt; Option&lt;Bytes&gt;;
    fn write(id: u64, b: Bytes) -&gt; Result&lt;usize, ()&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#non-send" id="non-send">Non-Send</a></h3>
<p>You can generate non-Send service by add <code>?Send</code> parameter to <code>norpc::service</code> macro.</p>
<p>This is useful when you want to run the service in pinned thread.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[norpc::service(?Send)]
trait YourService {
    // Rc&lt;T&gt; is !Send
    fn echo(s: Rc&lt;String&gt;) -&gt; Rc&lt;String&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#runtime" id="runtime">Runtime</a></h1>
<p><img src="images/norpc-stack.png" alt="" /></p>
<p>The yellow and blue parts are called &quot;norpc runtime&quot;.</p>
<p>As mentioned in the earlier section,
the code generated by the compiler (in red) are runtime-agnostic.</p>
<p>To run the service on a runtime, you need to implement 
the trait generated by the compiler.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct HelloWorldApp;
#[async_trait::async_trait]
impl HelloWorld for HelloWorldApp {
    async fn hello(&amp;self, s: String) -&gt; String {
        format!(&quot;Hello, {}&quot;, s)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And then you can build a server and a channel.
After spawning the server on a async runtime,
you can send requests to the server through the channel.
Note that the server is async runtime agnostic so you can
choose any async runtime to execute the server.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use norpc::runtime::*;
let app = HelloWorldApp;
let builder = ServerBuilder::new(HelloWorldService::new(app));
let (chan, server) = builder.build();

tokio::spawn(server.serve(TokioExecutor));

let mut cli = HelloWorldClient::new(chan);
assert_eq!(cli.hello(&quot;World&quot;.to_owned()).await, &quot;Hello, World&quot;);
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
